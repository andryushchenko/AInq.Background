<?xml version="1.0"?>
<doc>
    <assembly>
        <name>AInq.Background</name>
    </assembly>
    <members>
        <member name="T:AInq.Background.AccessQueueInjection">
            <summary> Shared resource Access Queue dependency injection </summary>
        </member>
        <member name="M:AInq.Background.AccessQueueInjection.CreateAccessQueue``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,``0,System.Int32)">
            <summary> Create <see cref="T:AInq.Background.Services.IAccessQueue`1" /> with single static shared resource without service registration </summary>
            <param name="services"> Service collection </param>
            <param name="resource"> Shared resource instance </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TResource"> Shared resource type </typeparam>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="resource" /> is NULL </exception>
        </member>
        <member name="M:AInq.Background.AccessQueueInjection.AddAccessQueue``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,``0,System.Int32)">
            <summary> Add <see cref="T:AInq.Background.Services.IAccessQueue`1" /> service with single static shared resource </summary>
            <param name="services"> Service collection </param>
            <param name="resource"> Shared resource instance </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TResource"> Shared resource type </typeparam>
            <exception cref="T:System.InvalidOperationException"> Thrown if service already exists </exception>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="resource" /> is NULL </exception>
        </member>
        <member name="M:AInq.Background.AccessQueueInjection.CreatePriorityAccessQueue``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,``0,System.Int32,System.Int32)">
            <summary> Create <see cref="T:AInq.Background.Services.IPriorityAccessQueue`1" /> with single static shared resource without service registration </summary>
            <param name="services"> Service collection </param>
            <param name="resource"> Shared resource instance </param>
            <param name="maxPriority"> Max allowed operation priority </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TResource"> Shared resource type </typeparam>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="resource" /> is NULL </exception>
        </member>
        <member name="M:AInq.Background.AccessQueueInjection.AddPriorityAccessQueue``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,``0,System.Int32,System.Int32)">
            <summary> Add <see cref="T:AInq.Background.Services.IPriorityAccessQueue`1" /> and <see cref="T:AInq.Background.Services.IAccessQueue`1" /> services with single static shared resource </summary>
            <param name="services"> Service collection </param>
            <param name="resource"> Shared resource instance </param>
            <param name="maxPriority"> Max allowed operation priority </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TResource"> Shared resource type </typeparam>
            <exception cref="T:System.InvalidOperationException"> Thrown if service already exists </exception>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="resource" /> is NULL </exception>
        </member>
        <member name="M:AInq.Background.AccessQueueInjection.CreateAccessQueue``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary> Create <see cref="T:AInq.Background.Services.IAccessQueue`1" /> with static shared resources without service registration </summary>
            <param name="services"> Service collection </param>
            <param name="resources"> Shared resources collection </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TResource"> Shared resource type </typeparam>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="resources" /> is NULL </exception>
            <exception cref="T:System.ArgumentException"> Thrown if <paramref name="resources" /> collection is empty </exception>
        </member>
        <member name="M:AInq.Background.AccessQueueInjection.AddAccessQueue``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary> Add <see cref="T:AInq.Background.Services.IAccessQueue`1" /> service with static shared resources </summary>
            <param name="services"> Service collection </param>
            <param name="resources"> Shared resources collection </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TResource"> Shared resource type </typeparam>
            <exception cref="T:System.InvalidOperationException"> Thrown if service already exists </exception>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="resources" /> is NULL </exception>
            <exception cref="T:System.ArgumentException"> Thrown if <paramref name="resources" /> collection is empty </exception>
        </member>
        <member name="M:AInq.Background.AccessQueueInjection.CreatePriorityAccessQueue``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary> Create <see cref="T:AInq.Background.Services.IPriorityAccessQueue`1" /> with static shared resources without service registration </summary>
            <param name="services"> Service collection </param>
            <param name="resources"> Shared resources collection </param>
            <param name="maxPriority"> Max allowed operation priority </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TResource"> Shared resource type </typeparam>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="resources" /> is NULL </exception>
            <exception cref="T:System.ArgumentException"> Thrown if <paramref name="resources" /> collection is empty </exception>
        </member>
        <member name="M:AInq.Background.AccessQueueInjection.AddPriorityAccessQueue``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary> Add <see cref="T:AInq.Background.Services.IPriorityAccessQueue`1" /> and <see cref="T:AInq.Background.Services.IAccessQueue`1" /> services with static shared resources </summary>
            <param name="services"> Service collection </param>
            <param name="resources"> Shared resources collection </param>
            <param name="maxPriority"> Max allowed operation priority </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TResource"> Shared resource type </typeparam>
            <exception cref="T:System.InvalidOperationException"> Thrown if service already exists </exception>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="resources" /> is NULL </exception>
            <exception cref="T:System.ArgumentException"> Thrown if <paramref name="resources" /> collection is empty </exception>
        </member>
        <member name="M:AInq.Background.AccessQueueInjection.CreateAccessQueue``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,``0},AInq.Background.ReuseStrategy,System.Int32,System.Int32)">
            <summary> Create <see cref="T:AInq.Background.Services.IAccessQueue`1" /> with given shared resources reuse <paramref name="strategy" /> without service registration </summary>
            <param name="services"> Service collection </param>
            <param name="resourceFactory"> Shared resource factory function </param>
            <param name="strategy"> Conveyor machines reuse strategy <seealso cref="T:AInq.Background.ReuseStrategy" /></param>
            <param name="maxResourceInstances"> Max allowed shared resource instances count </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TResource"> Shared resource type </typeparam>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="resourceFactory" /> is NULL </exception>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"> Thrown if <paramref name="strategy" /> has incorrect value </exception>
        </member>
        <member name="M:AInq.Background.AccessQueueInjection.AddAccessQueue``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,``0},AInq.Background.ReuseStrategy,System.Int32,System.Int32)">
            <summary> Add <see cref="T:AInq.Background.Services.IAccessQueue`1" /> service with given shared resources reuse <paramref name="strategy" /> </summary>
            <param name="services"> Service collection </param>
            <param name="resourceFactory"> Shared resource factory function </param>
            <param name="strategy"> Conveyor machines reuse strategy <seealso cref="T:AInq.Background.ReuseStrategy" /></param>
            <param name="maxResourceInstances"> Max allowed shared resource instances count </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TResource"> Shared resource type </typeparam>
            <exception cref="T:System.InvalidOperationException"> Thrown if service already exists </exception>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="resourceFactory" /> is NULL </exception>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"> Thrown if <paramref name="strategy" /> has incorrect value </exception>
        </member>
        <member name="M:AInq.Background.AccessQueueInjection.CreatePriorityAccessQueue``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,``0},AInq.Background.ReuseStrategy,System.Int32,System.Int32,System.Int32)">
            <summary>
                Create <see cref="T:AInq.Background.Services.IPriorityAccessQueue`1" /> with given shared resources reuse <paramref name="strategy" /> without service
                registration
            </summary>
            <param name="services"> Service collection </param>
            <param name="resourceFactory"> Shared resource factory function </param>
            <param name="strategy"> Conveyor machines reuse strategy <seealso cref="T:AInq.Background.ReuseStrategy" /></param>
            <param name="maxResourceInstances"> Max allowed shared resource instances count </param>
            <param name="maxPriority"> Max allowed operation priority </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TResource"> Shared resource type </typeparam>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="resourceFactory" /> is NULL </exception>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"> Thrown if <paramref name="strategy" /> has incorrect value </exception>
        </member>
        <member name="M:AInq.Background.AccessQueueInjection.AddPriorityAccessQueue``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,``0},AInq.Background.ReuseStrategy,System.Int32,System.Int32,System.Int32)">
            <summary>
                Add <see cref="T:AInq.Background.Services.IPriorityAccessQueue`1" /> and <see cref="T:AInq.Background.Services.IAccessQueue`1" /> services with given shared resources reuse
                <paramref name="strategy" />
            </summary>
            <param name="services"> Service collection </param>
            <param name="resourceFactory"> Shared resource factory function </param>
            <param name="strategy"> Conveyor machines reuse strategy <seealso cref="T:AInq.Background.ReuseStrategy" /></param>
            <param name="maxResourceInstances"> Max allowed shared resource instances count </param>
            <param name="maxPriority"> Max allowed operation priority </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TResource"> Shared resource type </typeparam>
            <exception cref="T:System.InvalidOperationException"> Thrown if service already exists </exception>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="resourceFactory" /> is NULL </exception>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"> Thrown if <paramref name="strategy" /> has incorrect value </exception>
        </member>
        <member name="M:AInq.Background.AccessQueueInjection.CreateAccessQueue``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,AInq.Background.ReuseStrategy,System.Int32,System.Int32)">
            <summary> Create <see cref="T:AInq.Background.Services.IAccessQueue`1" /> with given shared resources reuse <paramref name="strategy" /> without service registration </summary>
            <param name="services"> Service collection </param>
            <param name="strategy"> Conveyor machines reuse strategy <seealso cref="T:AInq.Background.ReuseStrategy" /></param>
            <param name="maxResourceInstances"> Max allowed shared resource instances count </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TResource"> Shared resource type </typeparam>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"> Thrown if <paramref name="strategy" /> has incorrect value </exception>
        </member>
        <member name="M:AInq.Background.AccessQueueInjection.AddAccessQueue``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,AInq.Background.ReuseStrategy,System.Int32,System.Int32)">
            <summary> Add <see cref="T:AInq.Background.Services.IAccessQueue`1" /> service with given shared resources reuse <paramref name="strategy" /> </summary>
            <param name="services"> Service collection </param>
            <param name="strategy"> Conveyor machines reuse strategy <seealso cref="T:AInq.Background.ReuseStrategy" /></param>
            <param name="maxResourceInstances"> Max allowed shared resource instances count </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TResource"> Shared resource type </typeparam>
            <exception cref="T:System.InvalidOperationException"> Thrown if service already exists </exception>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"> Thrown if <paramref name="strategy" /> has incorrect value </exception>
        </member>
        <member name="M:AInq.Background.AccessQueueInjection.CreatePriorityAccessQueue``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,AInq.Background.ReuseStrategy,System.Int32,System.Int32,System.Int32)">
            <summary>
                Create <see cref="T:AInq.Background.Services.IPriorityAccessQueue`1" /> with given shared resources reuse <paramref name="strategy" /> without service
                registration
            </summary>
            <param name="services"> Service collection </param>
            <param name="strategy"> Conveyor machines reuse strategy <seealso cref="T:AInq.Background.ReuseStrategy" /></param>
            <param name="maxResourceInstances"> Max allowed shared resource instances count </param>
            <param name="maxPriority"> Max allowed operation priority </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TResource"> Shared resource type </typeparam>
            <exception cref="T:System.InvalidOperationException"> Thrown if service already exists </exception>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"> Thrown if <paramref name="strategy" /> has incorrect value </exception>
        </member>
        <member name="M:AInq.Background.AccessQueueInjection.AddPriorityAccessQueue``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,AInq.Background.ReuseStrategy,System.Int32,System.Int32,System.Int32)">
            <summary>
                Add <see cref="T:AInq.Background.Services.IPriorityAccessQueue`1" /> and <see cref="T:AInq.Background.Services.IAccessQueue`1" /> services with given shared resources reuse
                <paramref name="strategy" />
            </summary>
            <param name="services"> Service collection </param>
            <param name="strategy"> Conveyor machines reuse strategy <seealso cref="T:AInq.Background.ReuseStrategy" /></param>
            <param name="maxResourceInstances"> Max allowed shared resource instances count </param>
            <param name="maxPriority"> Max allowed operation priority </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TResource"> Shared resource type </typeparam>
            <exception cref="T:System.InvalidOperationException"> Thrown if service already exists </exception>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"> Thrown if <paramref name="strategy" /> has incorrect value </exception>
        </member>
        <member name="T:AInq.Background.ConveyorInjection">
            <summary> Background data processing Conveyor dependency injection </summary>
        </member>
        <member name="M:AInq.Background.ConveyorInjection.CreateConveyor``2(Microsoft.Extensions.DependencyInjection.IServiceCollection,AInq.Background.Tasks.IConveyorMachine{``0,``1},System.Int32)">
            <summary> Create <see cref="T:AInq.Background.Services.IConveyor`2" /> with single static conveyor machine without service registration </summary>
            <param name="services"> Service collection </param>
            <param name="conveyorMachine"> Conveyor machine instance </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TData"> Input data type </typeparam>
            <typeparam name="TResult"> Processing result type </typeparam>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="conveyorMachine" /> is NULL </exception>
        </member>
        <member name="M:AInq.Background.ConveyorInjection.AddConveyor``2(Microsoft.Extensions.DependencyInjection.IServiceCollection,AInq.Background.Tasks.IConveyorMachine{``0,``1},System.Int32)">
            <summary> Add <see cref="T:AInq.Background.Services.IConveyor`2" /> service with single static conveyor machine </summary>
            <param name="services"> Service collection </param>
            <param name="conveyorMachine"> Conveyor machine instance </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TData"> Input data type </typeparam>
            <typeparam name="TResult"> Processing result type </typeparam>
            <exception cref="T:System.InvalidOperationException"> Thrown if service already exists </exception>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="conveyorMachine" /> is NULL </exception>
        </member>
        <member name="M:AInq.Background.ConveyorInjection.CreatePriorityConveyor``2(Microsoft.Extensions.DependencyInjection.IServiceCollection,AInq.Background.Tasks.IConveyorMachine{``0,``1},System.Int32,System.Int32)">
            <summary> Create <see cref="T:AInq.Background.Services.IPriorityConveyor`2" /> with single static conveyor machine without service registration </summary>
            <param name="services"> Service collection </param>
            <param name="conveyorMachine"> Conveyor machine instance </param>
            <param name="maxPriority"> Max allowed operation priority </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TData"> Input data type </typeparam>
            <typeparam name="TResult"> Processing result type </typeparam>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="conveyorMachine" /> is NULL </exception>
        </member>
        <member name="M:AInq.Background.ConveyorInjection.AddPriorityConveyor``2(Microsoft.Extensions.DependencyInjection.IServiceCollection,AInq.Background.Tasks.IConveyorMachine{``0,``1},System.Int32,System.Int32)">
            <summary>
                Add <see cref="T:AInq.Background.Services.IPriorityConveyor`2" /> and <see cref="T:AInq.Background.Services.IConveyor`2" /> services with single static conveyor
                machine
            </summary>
            <param name="services"> Service collection </param>
            <param name="conveyorMachine"> Conveyor machine instance </param>
            <param name="maxPriority"> Max allowed operation priority </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TData"> Input data type </typeparam>
            <typeparam name="TResult"> Processing result type </typeparam>
            <exception cref="T:System.InvalidOperationException"> Thrown if service already exists </exception>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="conveyorMachine" /> is NULL </exception>
        </member>
        <member name="M:AInq.Background.ConveyorInjection.CreateConveyor``2(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Collections.Generic.IEnumerable{AInq.Background.Tasks.IConveyorMachine{``0,``1}},System.Int32)">
            <summary> Create <see cref="T:AInq.Background.Services.IConveyor`2" /> with static conveyor machines without service registration </summary>
            <param name="services"> Service collection </param>
            <param name="conveyorMachines"> Conveyor machines collection </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TData"> Input data type </typeparam>
            <typeparam name="TResult"> Processing result type </typeparam>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="conveyorMachines" /> is NULL </exception>
            <exception cref="T:System.ArgumentException"> Thrown if <paramref name="conveyorMachines" /> collection is empty </exception>
        </member>
        <member name="M:AInq.Background.ConveyorInjection.AddConveyor``2(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Collections.Generic.IEnumerable{AInq.Background.Tasks.IConveyorMachine{``0,``1}},System.Int32)">
            <summary> Add <see cref="T:AInq.Background.Services.IConveyor`2" /> service with static conveyor machines </summary>
            <param name="services"> Service collection </param>
            <param name="conveyorMachines"> Conveyor machines collection </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TData"> Input data type </typeparam>
            <typeparam name="TResult"> Processing result type </typeparam>
            <exception cref="T:System.InvalidOperationException"> Thrown if service already exists </exception>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="conveyorMachines" /> is NULL </exception>
            <exception cref="T:System.ArgumentException"> Thrown if <paramref name="conveyorMachines" /> collection is empty </exception>
        </member>
        <member name="M:AInq.Background.ConveyorInjection.CreatePriorityConveyor``2(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Collections.Generic.IEnumerable{AInq.Background.Tasks.IConveyorMachine{``0,``1}},System.Int32,System.Int32)">
            <summary> Create <see cref="T:AInq.Background.Services.IPriorityConveyor`2" /> with static conveyor machines without service registration </summary>
            <param name="services"> Service collection </param>
            <param name="conveyorMachines"> Conveyor machines collection </param>
            <param name="maxPriority"> Max allowed operation priority </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TData"> Input data type </typeparam>
            <typeparam name="TResult"> Processing result type </typeparam>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="conveyorMachines" /> is NULL </exception>
            <exception cref="T:System.ArgumentException"> Thrown if <paramref name="conveyorMachines" /> collection is empty </exception>
        </member>
        <member name="M:AInq.Background.ConveyorInjection.AddPriorityConveyor``2(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Collections.Generic.IEnumerable{AInq.Background.Tasks.IConveyorMachine{``0,``1}},System.Int32,System.Int32)">
            <summary> Add <see cref="T:AInq.Background.Services.IPriorityConveyor`2" /> and <see cref="T:AInq.Background.Services.IConveyor`2" /> services with static conveyor machines </summary>
            <param name="services"> Service collection </param>
            <param name="conveyorMachines"> Conveyor machines collection </param>
            <param name="maxPriority"> Max allowed operation priority </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TData"> Input data type </typeparam>
            <typeparam name="TResult"> Processing result type </typeparam>
            <exception cref="T:System.InvalidOperationException"> Thrown if service already exists </exception>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="conveyorMachines" /> is NULL </exception>
            <exception cref="T:System.ArgumentException"> Thrown if <paramref name="conveyorMachines" /> collection is empty </exception>
        </member>
        <member name="M:AInq.Background.ConveyorInjection.CreateConveyor``2(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,AInq.Background.Tasks.IConveyorMachine{``0,``1}},AInq.Background.ReuseStrategy,System.Int32,System.Int32)">
            <summary>
                Create <see cref="T:AInq.Background.Services.IConveyor`2" /> with given conveyor machines reuse <paramref name="strategy" /> without service
                registration
            </summary>
            <param name="services"> Service collection </param>
            <param name="conveyorMachineFactory"> Conveyor machine factory function </param>
            <param name="strategy"> Conveyor machines reuse strategy <seealso cref="T:AInq.Background.ReuseStrategy" /></param>
            <param name="maxParallelMachines"> Max allowed parallel conveyor machines </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TData"> Input data type </typeparam>
            <typeparam name="TResult"> Processing result type </typeparam>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="conveyorMachineFactory" /> is NULL </exception>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"> Thrown if <paramref name="strategy" /> has incorrect value </exception>
        </member>
        <member name="M:AInq.Background.ConveyorInjection.AddConveyor``2(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,AInq.Background.Tasks.IConveyorMachine{``0,``1}},AInq.Background.ReuseStrategy,System.Int32,System.Int32)">
            <summary> Add <see cref="T:AInq.Background.Services.IConveyor`2" /> service with given conveyor machines reuse <paramref name="strategy" /> </summary>
            <param name="services"> Service collection </param>
            <param name="conveyorMachineFactory"> Conveyor machine factory function </param>
            <param name="strategy"> Conveyor machines reuse strategy <seealso cref="T:AInq.Background.ReuseStrategy" /></param>
            <param name="maxParallelMachines"> Max allowed parallel conveyor machines </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TData"> Input data type </typeparam>
            <typeparam name="TResult"> Processing result type </typeparam>
            <exception cref="T:System.InvalidOperationException"> Thrown if service already exists </exception>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="conveyorMachineFactory" /> is NULL </exception>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"> Thrown if <paramref name="strategy" /> has incorrect value </exception>
        </member>
        <member name="M:AInq.Background.ConveyorInjection.CreatePriorityConveyor``2(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,AInq.Background.Tasks.IConveyorMachine{``0,``1}},AInq.Background.ReuseStrategy,System.Int32,System.Int32,System.Int32)">
            <summary>
                Create <see cref="T:AInq.Background.Services.IPriorityConveyor`2" /> with given conveyor machines reuse <paramref name="strategy" /> without service
                registration
            </summary>
            <param name="services"> Service collection </param>
            <param name="conveyorMachineFactory"> Conveyor machine factory function </param>
            <param name="strategy"> Conveyor machines reuse strategy <seealso cref="T:AInq.Background.ReuseStrategy" /></param>
            <param name="maxParallelMachines"> Max allowed parallel conveyor machines </param>
            <param name="maxPriority"> Max allowed operation priority </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TData"> Input data type </typeparam>
            <typeparam name="TResult"> Processing result type </typeparam>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="conveyorMachineFactory" /> is NULL </exception>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"> Thrown if <paramref name="strategy" /> has incorrect value </exception>
        </member>
        <member name="M:AInq.Background.ConveyorInjection.AddPriorityConveyor``2(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,AInq.Background.Tasks.IConveyorMachine{``0,``1}},AInq.Background.ReuseStrategy,System.Int32,System.Int32,System.Int32)">
            <summary>
                Add <see cref="T:AInq.Background.Services.IPriorityConveyor`2" /> and <see cref="T:AInq.Background.Services.IConveyor`2" /> services with given conveyor machines
                reuse <paramref name="strategy" />
            </summary>
            <param name="services"> Service collection </param>
            <param name="conveyorMachineFactory"> Conveyor machine factory function </param>
            <param name="strategy"> Conveyor machines reuse strategy <seealso cref="T:AInq.Background.ReuseStrategy" /></param>
            <param name="maxParallelMachines"> Max allowed parallel conveyor machines </param>
            <param name="maxPriority"> Max allowed operation priority </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TData"> Input data type </typeparam>
            <typeparam name="TResult"> Processing result type </typeparam>
            <exception cref="T:System.InvalidOperationException"> Thrown if service already exists </exception>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="conveyorMachineFactory" /> is NULL </exception>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"> Thrown if <paramref name="strategy" /> has incorrect value </exception>
        </member>
        <member name="M:AInq.Background.ConveyorInjection.CreateConveyor``3(Microsoft.Extensions.DependencyInjection.IServiceCollection,AInq.Background.ReuseStrategy,System.Int32,System.Int32)">
            <summary>
                Create <see cref="T:AInq.Background.Services.IConveyor`2" /> with given conveyor machines reuse <paramref name="strategy" /> without service
                registration
            </summary>
            <param name="services"> Service collection </param>
            <param name="strategy"> Conveyor machines reuse strategy <seealso cref="T:AInq.Background.ReuseStrategy" /></param>
            <param name="maxParallelMachines"> Max allowed parallel conveyor machines </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TData"> Input data type </typeparam>
            <typeparam name="TResult"> Processing result type </typeparam>
            <typeparam name="TConveyorMachine"> Conveyor machine type </typeparam>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"> Thrown if <paramref name="strategy" /> has incorrect value </exception>
        </member>
        <member name="M:AInq.Background.ConveyorInjection.AddConveyor``3(Microsoft.Extensions.DependencyInjection.IServiceCollection,AInq.Background.ReuseStrategy,System.Int32,System.Int32)">
            <summary> Add <see cref="T:AInq.Background.Services.IConveyor`2" /> service with given conveyor machines reuse <paramref name="strategy" /> </summary>
            <param name="services"> Service collection </param>
            <param name="strategy"> Conveyor machines reuse strategy <seealso cref="T:AInq.Background.ReuseStrategy" /></param>
            <param name="maxParallelMachines"> Max allowed parallel conveyor machines </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TData"> Input data type </typeparam>
            <typeparam name="TResult"> Processing result type </typeparam>
            <typeparam name="TConveyorMachine"> Conveyor machine type </typeparam>
            <exception cref="T:System.InvalidOperationException"> Thrown if service already exists </exception>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"> Thrown if <paramref name="strategy" /> has incorrect value </exception>
        </member>
        <member name="M:AInq.Background.ConveyorInjection.CreatePriorityConveyor``3(Microsoft.Extensions.DependencyInjection.IServiceCollection,AInq.Background.ReuseStrategy,System.Int32,System.Int32,System.Int32)">
            <summary>
                Create <see cref="T:AInq.Background.Services.IPriorityConveyor`2" /> with given conveyor machines reuse <paramref name="strategy" /> without service
                registration
            </summary>
            <param name="services"> Service collection </param>
            <param name="strategy"> Conveyor machines reuse strategy <seealso cref="T:AInq.Background.ReuseStrategy" /></param>
            <param name="maxParallelMachines"> Max allowed parallel conveyor machines </param>
            <param name="maxPriority"> Max allowed operation priority </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TData"> Input data type </typeparam>
            <typeparam name="TResult"> Processing result type </typeparam>
            <typeparam name="TConveyorMachine"> Conveyor machine type </typeparam>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"> Thrown if <paramref name="strategy" /> has incorrect value </exception>
        </member>
        <member name="M:AInq.Background.ConveyorInjection.AddPriorityConveyor``3(Microsoft.Extensions.DependencyInjection.IServiceCollection,AInq.Background.ReuseStrategy,System.Int32,System.Int32,System.Int32)">
            <summary>
                Add <see cref="T:AInq.Background.Services.IPriorityConveyor`2" /> and <see cref="T:AInq.Background.Services.IConveyor`2" /> services with given conveyor machines
                reuse <paramref name="strategy" />
            </summary>
            <param name="services"> Service collection </param>
            <param name="strategy"> Conveyor machines reuse strategy <seealso cref="T:AInq.Background.ReuseStrategy" /></param>
            <param name="maxParallelMachines"> Max allowed parallel conveyor machines </param>
            <param name="maxPriority"> Max allowed operation priority </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <typeparam name="TData"> Input data type </typeparam>
            <typeparam name="TResult"> Processing result type </typeparam>
            <typeparam name="TConveyorMachine"> Conveyor machine type </typeparam>
            <exception cref="T:System.InvalidOperationException"> Thrown if service already exists </exception>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"> Thrown if <paramref name="strategy" /> has incorrect value </exception>
        </member>
        <member name="T:AInq.Background.Managers.AccessQueueManager`1">
            <summary> Background access queue manager </summary>
            <typeparam name="TResource"> Shared resource type </typeparam>
        </member>
        <member name="M:AInq.Background.Managers.AccessQueueManager`1.#ctor(System.Int32)">
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
        </member>
        <member name="T:AInq.Background.Managers.ConveyorManager`2">
            <summary> Background data conveyor manager </summary>
            <typeparam name="TData"> Input data type </typeparam>
            <typeparam name="TResult"> Processing result type </typeparam>
        </member>
        <member name="M:AInq.Background.Managers.ConveyorManager`2.#ctor(System.Int32)">
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
        </member>
        <member name="T:AInq.Background.Managers.ITaskManager`2">
            <summary> Interface for background task manager </summary>
            <typeparam name="TArgument"> Task argument type </typeparam>
            <typeparam name="TMetadata"> Task metadata type </typeparam>
        </member>
        <member name="P:AInq.Background.Managers.ITaskManager`2.HasTask">
            <summary> Check if manager has pending tasks </summary>
        </member>
        <member name="M:AInq.Background.Managers.ITaskManager`2.WaitForTaskAsync(System.Threading.CancellationToken)">
            <summary> Asynchronously wait wor pending tasks </summary>
            <param name="cancellation"> Wait cancellation token </param>
        </member>
        <member name="M:AInq.Background.Managers.ITaskManager`2.GetTask">
            <summary> Get first pending task </summary>
            <returns> Task wrapper and task metadata </returns>
        </member>
        <member name="M:AInq.Background.Managers.ITaskManager`2.RevertTask(AInq.Background.Wrappers.ITaskWrapper{`0},`1)">
            <summary> Revert uncompleted task to manager </summary>
            <param name="task"> Task instance </param>
            <param name="metadata"> Task metadata </param>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="task" /> or <paramref name="metadata" /> is NULL</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> Thrown if <paramref name="metadata" /> has incorrect value </exception>
        </member>
        <member name="T:AInq.Background.Managers.PriorityAccessQueueManager`1">
            <summary> Background access queue manager with numeric prioritization </summary>
            <typeparam name="TResource"> Shared resource type </typeparam>
        </member>
        <member name="M:AInq.Background.Managers.PriorityAccessQueueManager`1.#ctor(System.Int32,System.Int32)">
            <param name="maxPriority"> Max allowed work priority </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
        </member>
        <member name="T:AInq.Background.Managers.PriorityConveyorManager`2">
            <summary> Background data conveyor manager with numeric prioritization </summary>
            <typeparam name="TData"> Input data type </typeparam>
            <typeparam name="TResult"> Processing result type </typeparam>
        </member>
        <member name="M:AInq.Background.Managers.PriorityConveyorManager`2.#ctor(System.Int32,System.Int32)">
            <param name="maxPriority"> Max allowed work priority </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
        </member>
        <member name="T:AInq.Background.Managers.PriorityTaskManager`1">
            <summary> Basic task manager with numeric prioritization </summary>
            <typeparam name="TArgument"> Task argument type </typeparam>
        </member>
        <member name="M:AInq.Background.Managers.PriorityTaskManager`1.#ctor(System.Int32)">
            <param name="maxPriority"> Max allowed priority </param>
        </member>
        <member name="P:AInq.Background.Managers.PriorityTaskManager`1.MaxPriority">
            <summary> Max allowed priority </summary>
        </member>
        <member name="M:AInq.Background.Managers.PriorityTaskManager`1.AddTask(AInq.Background.Wrappers.ITaskWrapper{`0},System.Int32)">
            <summary> Add task to queue </summary>
            <param name="task"> Task instance </param>
            <param name="priority"> Task priority </param>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="task" /> is NULL </exception>
        </member>
        <member name="T:AInq.Background.Managers.PriorityWorkQueueManager">
            <summary> Background work queue manager with numeric prioritization </summary>
        </member>
        <member name="M:AInq.Background.Managers.PriorityWorkQueueManager.#ctor(System.Int32,System.Int32)">
            <param name="maxPriority"> Max allowed work priority </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
        </member>
        <member name="T:AInq.Background.Managers.TaskManager`1">
            <summary> Basic task manager with single queue </summary>
            <typeparam name="TArgument"> Task argument type </typeparam>
        </member>
        <member name="M:AInq.Background.Managers.TaskManager`1.AddTask(AInq.Background.Wrappers.ITaskWrapper{`0})">
            <summary> Add task to queue </summary>
            <param name="task"> Task instance </param>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="task" /> is NULL </exception>
        </member>
        <member name="T:AInq.Background.Managers.WorkQueueManager">
            <summary> Background work queue manager </summary>
        </member>
        <member name="M:AInq.Background.Managers.WorkQueueManager.#ctor(System.Int32)">
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
        </member>
        <member name="T:AInq.Background.Processors.ITaskProcessor`2">
            <summary> Interface for task processor </summary>
            <typeparam name="TArgument"> Task argument type </typeparam>
            <typeparam name="TMetadata"> Task metadata type </typeparam>
        </member>
        <member name="M:AInq.Background.Processors.ITaskProcessor`2.ProcessPendingTasksAsync(AInq.Background.Managers.ITaskManager{`0,`1},System.IServiceProvider,Microsoft.Extensions.Logging.ILogger,System.Threading.CancellationToken)">
            <summary> Process pending tasks form given <paramref name="manager"/> </summary>
            <param name="manager"> Task manager instance </param>
            <param name="provider"> Service provider instance </param>
            <param name="logger"> Logger instance </param>
            <param name="cancellation"> Cancellation token </param>
            <returns></returns>
        </member>
        <member name="T:AInq.Background.Processors.ProcessorFactory">
            <summary> Task processor factory class </summary>
        </member>
        <member name="M:AInq.Background.Processors.ProcessorFactory.CreateNullProcessor``1(System.Int32)">
            <summary> Create NULL-argument task processor (used in background work queue) </summary>
            <param name="maxParallelTasks"> Max allowed parallel tasks </param>
            <typeparam name="TMetadata"> Task metadata type </typeparam>
            <returns> Task processor instance </returns>
        </member>
        <member name="M:AInq.Background.Processors.ProcessorFactory.CreateProcessor``2(``0)">
            <summary> Create task processor with single static argument </summary>
            <param name="argument"> Task argument </param>
            <typeparam name="TArgument"> Task argument type </typeparam>
            <typeparam name="TMetadata"> Task metadata type </typeparam>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="argument"/> is NULL </exception>
            <returns> Task processor instance </returns>
        </member>
        <member name="M:AInq.Background.Processors.ProcessorFactory.CreateProcessor``2(System.Collections.Generic.IEnumerable{``0})">
            <summary> Create task processor with static arguments </summary>
            <param name="arguments"> Task arguments collection </param>
            <typeparam name="TArgument"> Task argument type </typeparam>
            <typeparam name="TMetadata"> Task metadata type </typeparam>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="arguments"/> is NULL </exception>
            <exception cref="T:System.ArgumentException"> Thrown if <paramref name="arguments"/> is empty collection </exception>
            <returns> Task processor instance </returns>
        </member>
        <member name="M:AInq.Background.Processors.ProcessorFactory.CreateProcessor``2(System.Func{System.IServiceProvider,``0},AInq.Background.ReuseStrategy,System.IServiceProvider,System.Int32)">
            <summary> Create task processor with given argument reuse strategy </summary>
            <param name="argumentFactory"> Argument factory </param>
            <param name="strategy"> Argument reuse strategy </param>
            <param name="provider"> Service provider instance (used only for <see cref="F:AInq.Background.ReuseStrategy.Static"/> strategy) </param>
            <param name="maxArgumentsCount"> Max allowed argument instances </param>
            <typeparam name="TArgument"> Task argument type </typeparam>
            <typeparam name="TMetadata"> Task metadata type </typeparam>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="argumentFactory"/> or <paramref name="provider"/> (if used) is NULL </exception>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"> Thrown if <paramref name="strategy" /> has incorrect value </exception>
            <returns> Task processor instance </returns>
        </member>
        <member name="T:AInq.Background.ReuseStrategy">
            <summary> Reuse strategy for Shared Resources and Conveyor Machines </summary>
        </member>
        <member name="F:AInq.Background.ReuseStrategy.Static">
            <summary> Generate once at startup and reuse </summary>
        </member>
        <member name="F:AInq.Background.ReuseStrategy.Reuse">
            <summary> Generate new for each actions batch, reuse in batch </summary>
        </member>
        <member name="F:AInq.Background.ReuseStrategy.OneTime">
            <summary> Generate new for each action </summary>
        </member>
        <member name="T:AInq.Background.StartupWorkInjection">
            <summary> Startup work injection </summary>
        </member>
        <member name="M:AInq.Background.StartupWorkInjection.DoStartupWork(Microsoft.Extensions.Hosting.IHost,System.Threading.CancellationToken)">
            <summary> Run registered startup works asynchronously </summary>
            <param name="host"> Current host </param>
            <param name="cancellation"> Startup work cancellation token </param>
            <returns></returns>
        </member>
        <member name="M:AInq.Background.StartupWorkInjection.AddStartupWork(Microsoft.Extensions.DependencyInjection.IServiceCollection,AInq.Background.Tasks.IWork)">
            <summary> Register startup work </summary>
            <param name="services"> Service collection </param>
            <param name="work"> Work instance </param>
        </member>
        <member name="M:AInq.Background.StartupWorkInjection.AddStartupWork``1(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary> Register startup work </summary>
            <param name="services"> Service collection </param>
            <typeparam name="TWork"> Work type </typeparam>
        </member>
        <member name="M:AInq.Background.StartupWorkInjection.AddStartupWork``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,AInq.Background.Tasks.IWork{``0})">
            <summary> Register startup work </summary>
            <param name="services"> Service collection </param>
            <param name="work"> Work instance </param>
            <typeparam name="TResult"> Work result type </typeparam>
        </member>
        <member name="M:AInq.Background.StartupWorkInjection.AddStartupWork``2(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary> Register startup work </summary>
            <param name="services"> Service collection </param>
            <typeparam name="TWork"> Work type </typeparam>
            <typeparam name="TResult"> Work result type </typeparam>
        </member>
        <member name="M:AInq.Background.StartupWorkInjection.AddStartupAsyncWork(Microsoft.Extensions.DependencyInjection.IServiceCollection,AInq.Background.Tasks.IAsyncWork)">
            <summary> Register asynchronous startup work </summary>
            <param name="services"> Service collection </param>
            <param name="work"> Work instance </param>
        </member>
        <member name="M:AInq.Background.StartupWorkInjection.AddStartupAsyncWork``1(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary> Register asynchronous startup work </summary>
            <param name="services"> Service collection </param>
            <typeparam name="TAsyncWork"> Work type </typeparam>
        </member>
        <member name="M:AInq.Background.StartupWorkInjection.AddStartupAsyncWork``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,AInq.Background.Tasks.IAsyncWork{``0})">
            <summary> Register asynchronous startup work </summary>
            <param name="services"> Service collection </param>
            <param name="work"> Work instance </param>
        </member>
        <member name="M:AInq.Background.StartupWorkInjection.AddStartupAsyncWork``2(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary> Register asynchronous startup work </summary>
            <param name="services"> Service collection </param>
            <typeparam name="TAsyncWork"> Work type </typeparam>
            <typeparam name="TResult"> Work result type </typeparam>
        </member>
        <member name="M:AInq.Background.StartupWorkInjection.AddStartupQueuedWork(Microsoft.Extensions.DependencyInjection.IServiceCollection,AInq.Background.Tasks.IWork,System.Int32,System.Int32)">
            <summary> Register queued startup work with given <paramref name="priority" /> (if supported) </summary>
            <remarks> <see cref="T:AInq.Background.Services.IPriorityWorkQueue" /> or <see cref="T:AInq.Background.Services.IWorkQueue" /> service should be registered on host to run queued work </remarks>
            <param name="services"> Service collection </param>
            <param name="work"> Work instance </param>
            <param name="attemptsCount"> Retry on fail attempts count </param>
            <param name="priority"> Work priority </param>
        </member>
        <member name="M:AInq.Background.StartupWorkInjection.AddStartupQueuedWork``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Int32,System.Int32)">
            <summary> Register queued startup work with given <paramref name="priority" /> (if supported) </summary>
            <remarks> <see cref="T:AInq.Background.Services.IPriorityWorkQueue" /> or <see cref="T:AInq.Background.Services.IWorkQueue" /> service should be registered on host to run queued work </remarks>
            <param name="services"> Service collection </param>
            <param name="attemptsCount"> Retry on fail attempts count </param>
            <param name="priority"> Work priority </param>
            <typeparam name="TWork"> Work type </typeparam>
        </member>
        <member name="M:AInq.Background.StartupWorkInjection.AddStartupQueuedWork``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,AInq.Background.Tasks.IWork{``0},System.Int32,System.Int32)">
            <summary> Register queued startup work with given <paramref name="priority" /> (if supported) </summary>
            <remarks> <see cref="T:AInq.Background.Services.IPriorityWorkQueue" /> or <see cref="T:AInq.Background.Services.IWorkQueue" /> service should be registered on host to run queued work </remarks>
            <param name="services"> Service collection </param>
            <param name="work"> Work instance </param>
            <param name="attemptsCount"> Retry on fail attempts count </param>
            <param name="priority"> Work priority </param>
            <typeparam name="TResult"> Work result type </typeparam>
        </member>
        <member name="M:AInq.Background.StartupWorkInjection.AddStartupQueuedWork``2(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Int32,System.Int32)">
            <summary> Register queued startup work with given <paramref name="priority" /> (if supported) </summary>
            <remarks> <see cref="T:AInq.Background.Services.IPriorityWorkQueue" /> or <see cref="T:AInq.Background.Services.IWorkQueue" /> service should be registered on host to run queued work </remarks>
            <param name="services"> Service collection </param>
            <param name="attemptsCount"> Retry on fail attempts count </param>
            <param name="priority"> Work priority </param>
            <typeparam name="TWork"> Work type </typeparam>
            <typeparam name="TResult"> Work result type </typeparam>
        </member>
        <member name="M:AInq.Background.StartupWorkInjection.AddStartupAsyncQueuedWork(Microsoft.Extensions.DependencyInjection.IServiceCollection,AInq.Background.Tasks.IAsyncWork,System.Int32,System.Int32)">
            <summary> Register asynchronous queued startup work with given <paramref name="priority" /> (if supported) </summary>
            <remarks> <see cref="T:AInq.Background.Services.IPriorityWorkQueue" /> or <see cref="T:AInq.Background.Services.IWorkQueue" /> service should be registered on host to run queued work </remarks>
            <param name="services"> Service collection </param>
            <param name="work"> Work instance </param>
            <param name="attemptsCount"> Retry on fail attempts count </param>
            <param name="priority"> Work priority </param>
        </member>
        <member name="M:AInq.Background.StartupWorkInjection.AddStartupAsyncQueuedWork``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Int32,System.Int32)">
            <summary> Register asynchronous queued startup work with given <paramref name="priority" /> (if supported) </summary>
            <remarks> <see cref="T:AInq.Background.Services.IPriorityWorkQueue" /> or <see cref="T:AInq.Background.Services.IWorkQueue" /> service should be registered on host to run queued work </remarks>
            <param name="services"> Service collection </param>
            <param name="attemptsCount"> Retry on fail attempts count </param>
            <param name="priority"> Work priority </param>
            <typeparam name="TAsyncWork"> Work type </typeparam>
        </member>
        <member name="M:AInq.Background.StartupWorkInjection.AddStartupAsyncQueuedWork``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,AInq.Background.Tasks.IAsyncWork{``0},System.Int32,System.Int32)">
            <summary> Register asynchronous queued startup work with given <paramref name="priority" /> (if supported) </summary>
            <remarks> <see cref="T:AInq.Background.Services.IPriorityWorkQueue" /> or <see cref="T:AInq.Background.Services.IWorkQueue" /> service should be registered on host to run queued work </remarks>
            <param name="services"> Service collection </param>
            <param name="work"> Work instance </param>
            <param name="attemptsCount"> Retry on fail attempts count </param>
            <param name="priority"> Work priority </param>
            <typeparam name="TResult"> Work result type </typeparam>
        </member>
        <member name="M:AInq.Background.StartupWorkInjection.AddStartupAsyncQueuedWork``2(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Int32,System.Int32)">
            <summary> Register asynchronous queued startup work with given <paramref name="priority" /> (if supported) </summary>
            <remarks> <see cref="T:AInq.Background.Services.IPriorityWorkQueue" /> or <see cref="T:AInq.Background.Services.IWorkQueue" /> service should be registered on host to run queued work </remarks>
            <param name="services"> Service collection </param>
            <param name="attemptsCount"> Retry on fail attempts count </param>
            <param name="priority"> Work priority </param>
            <typeparam name="TAsyncWork"> Work type </typeparam>
            <typeparam name="TResult"> Work result type </typeparam>
        </member>
        <member name="T:AInq.Background.Workers.TaskWorker`2">
            <summary> Background task worker service </summary>
            <typeparam name="TArgument"> Task argument type </typeparam>
            <typeparam name="TMetadata"> Task metadata type </typeparam>
        </member>
        <member name="M:AInq.Background.Workers.TaskWorker`2.#ctor(System.IServiceProvider,AInq.Background.Managers.ITaskManager{`0,`1},AInq.Background.Processors.ITaskProcessor{`0,`1})">
            <param name="provider"> Service provider instance </param>
            <param name="manager"> Task manager instance </param>
            <param name="processor"> Task processor instance </param>
        </member>
        <member name="T:AInq.Background.WorkQueueInjection">
            <summary> Background Work Queue dependency injection </summary>
        </member>
        <member name="M:AInq.Background.WorkQueueInjection.CreateWorkQueue(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Int32,System.Int32)">
            <summary> Create <see cref="T:AInq.Background.Services.IWorkQueue" /> without service registration </summary>
            <param name="services"> Service collection </param>
            <param name="maxParallelWorks"> Max parallel works allowed </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
        </member>
        <member name="M:AInq.Background.WorkQueueInjection.AddWorkQueue(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Int32,System.Int32)">
            <summary> Add <see cref="T:AInq.Background.Services.IWorkQueue" /> service </summary>
            <param name="services"> Service collection </param>
            <param name="maxParallelWorks"> Max parallel works allowed </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <exception cref="T:System.InvalidOperationException"> Thrown if service already exists </exception>
        </member>
        <member name="M:AInq.Background.WorkQueueInjection.CreatePriorityWorkQueue(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Int32,System.Int32,System.Int32)">
            <summary> Create <see cref="T:AInq.Background.Services.IPriorityWorkQueue" /> without service registration </summary>
            <param name="services"> Service collection </param>
            <param name="maxPriority"> Max allowed work priority </param>
            <param name="maxParallelWorks"> Max allowed parallel works </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
        </member>
        <member name="M:AInq.Background.WorkQueueInjection.AddPriorityWorkQueue(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Int32,System.Int32,System.Int32)">
            <summary> Add <see cref="T:AInq.Background.Services.IPriorityWorkQueue" /> and <see cref="T:AInq.Background.Services.IWorkQueue" /> services </summary>
            <param name="services"> Service collection </param>
            <param name="maxPriority"> Max allowed work priority </param>
            <param name="maxParallelWorks"> Max allowed parallel works </param>
            <param name="maxAttempts"> Max allowed retry on fail attempts </param>
            <exception cref="T:System.InvalidOperationException"> Thrown if service already exists </exception>
        </member>
        <member name="T:AInq.Background.Wrappers.AccessWrapperFactory">
            <summary> Factory class for creating <see cref="T:AInq.Background.Wrappers.ITaskWrapper`1" /> for background access queues </summary>
        </member>
        <member name="M:AInq.Background.Wrappers.AccessWrapperFactory.CreateAccessWrapper``1(AInq.Background.Tasks.IAccess{``0},System.Int32,System.Threading.CancellationToken)">
            <summary> Create <see cref="T:AInq.Background.Wrappers.ITaskWrapper`1" /> for given access action </summary>
            <param name="access"> Access action instance </param>
            <param name="attemptsCount"> Retry on fail attempts count </param>
            <param name="cancellation"> Work cancellation token </param>
            <typeparam name="TResource"> Shared resource type </typeparam>
            <returns> Wrapper and access action completion task </returns>
        </member>
        <member name="M:AInq.Background.Wrappers.AccessWrapperFactory.CreateAccessWrapper``2(AInq.Background.Tasks.IAccess{``0,``1},System.Int32,System.Threading.CancellationToken)">
            <summary> Create <see cref="T:AInq.Background.Wrappers.ITaskWrapper`1" /> for given access action </summary>
            <param name="access"> Access action instance </param>
            <param name="attemptsCount"> Retry on fail attempts count </param>
            <param name="cancellation"> Work cancellation token </param>
            <typeparam name="TResource"> Shared resource type </typeparam>
            <typeparam name="TResult"> Access action result type </typeparam>
            <returns> Wrapper and access action result task </returns>
        </member>
        <member name="M:AInq.Background.Wrappers.AccessWrapperFactory.CreateAccessWrapper``1(AInq.Background.Tasks.IAsyncAccess{``0},System.Int32,System.Threading.CancellationToken)">
            <summary> Create <see cref="T:AInq.Background.Wrappers.ITaskWrapper`1" /> for given asynchronous access action </summary>
            <param name="access"> Access action instance </param>
            <param name="attemptsCount"> Retry on fail attempts count </param>
            <param name="cancellation"> Work cancellation token </param>
            <typeparam name="TResource"> Shared resource type </typeparam>
            <returns> Wrapper and access action completion task </returns>
        </member>
        <member name="M:AInq.Background.Wrappers.AccessWrapperFactory.CreateAccessWrapper``2(AInq.Background.Tasks.IAsyncAccess{``0,``1},System.Int32,System.Threading.CancellationToken)">
            <summary> Create <see cref="T:AInq.Background.Wrappers.ITaskWrapper`1" /> for given asynchronous access action </summary>
            <param name="access"> Access action instance </param>
            <param name="attemptsCount"> Retry on fail attempts count </param>
            <param name="cancellation"> Work cancellation token </param>
            <typeparam name="TResource"> Shared resource type </typeparam>
            <typeparam name="TResult"> Access action result type </typeparam>
            <returns> Wrapper and access action result task </returns>
        </member>
        <member name="T:AInq.Background.Wrappers.ConveyorDataWrapperFactory">
            <summary> Factory class for creating <see cref="T:AInq.Background.Wrappers.ITaskWrapper`1" /> for background data conveyors </summary>
        </member>
        <member name="M:AInq.Background.Wrappers.ConveyorDataWrapperFactory.CreateConveyorDataWrapper``2(``0,System.Int32,System.Threading.CancellationToken)">
            <summary> Create <see cref="T:AInq.Background.Wrappers.ITaskWrapper`1" /> with given conveyor data </summary>
            <param name="data"> Conveyor data </param>
            <param name="attemptsCount"> Retry on fail attempts count </param>
            <param name="cancellation"> Processing cancellation token </param>
            <typeparam name="TData"> Conveyor input data type </typeparam>
            <typeparam name="TResult"> Processing result type </typeparam>
            <returns> Wrapper and processing result task </returns>
        </member>
        <member name="T:AInq.Background.Wrappers.ITaskWrapper`1">
            <summary> Interface for background task wrappers </summary>
            <typeparam name="TArgument"> Task argument type </typeparam>
        </member>
        <member name="P:AInq.Background.Wrappers.ITaskWrapper`1.IsCanceled">
            <summary> Check if task is cancelled </summary>
        </member>
        <member name="P:AInq.Background.Wrappers.ITaskWrapper`1.IsCompleted">
            <summary> Check if task is completed </summary>
        </member>
        <member name="P:AInq.Background.Wrappers.ITaskWrapper`1.IsFaulted">
            <summary> Check if task is faulted </summary>
        </member>
        <member name="M:AInq.Background.Wrappers.ITaskWrapper`1.ExecuteAsync(`0,System.IServiceProvider,Microsoft.Extensions.Logging.ILogger,System.Threading.CancellationToken)">
            <summary> Execute task asynchronously </summary>
            <param name="argument"> Task argument </param>
            <param name="provider"> Service provider instance </param>
            <param name="logger"> Logger instance </param>
            <param name="cancellation"> Cancellation token </param>
            <returns> If task is completed or should be reverted to queue/conveyor </returns>
        </member>
        <member name="T:AInq.Background.Wrappers.WorkWrapperFactory">
            <summary> Factory class for creating <see cref="T:AInq.Background.Wrappers.ITaskWrapper`1" /> for background work queues </summary>
        </member>
        <member name="M:AInq.Background.Wrappers.WorkWrapperFactory.CreateWorkWrapper(AInq.Background.Tasks.IWork,System.Int32,System.Threading.CancellationToken)">
            <summary> Create <see cref="T:AInq.Background.Wrappers.ITaskWrapper`1" /> for given work </summary>
            <param name="work"> Work instance </param>
            <param name="attemptsCount"> Retry on fail attempts count </param>
            <param name="cancellation"> Work cancellation token </param>
            <returns> Wrapper and work completion task </returns>
        </member>
        <member name="M:AInq.Background.Wrappers.WorkWrapperFactory.CreateWorkWrapper``1(AInq.Background.Tasks.IWork{``0},System.Int32,System.Threading.CancellationToken)">
            <summary> Create <see cref="T:AInq.Background.Wrappers.ITaskWrapper`1" /> for given work </summary>
            <param name="work"> Work instance </param>
            <param name="attemptsCount"> Retry on fail attempts count </param>
            <param name="cancellation"> Work cancellation token </param>
            <typeparam name="TResult"> Work result type </typeparam>
            <returns> Wrapper and work result task </returns>
        </member>
        <member name="M:AInq.Background.Wrappers.WorkWrapperFactory.CreateWorkWrapper(AInq.Background.Tasks.IAsyncWork,System.Int32,System.Threading.CancellationToken)">
            <summary> Create <see cref="T:AInq.Background.Wrappers.ITaskWrapper`1" /> for given asynchronous work </summary>
            <param name="work"> Work instance </param>
            <param name="attemptsCount"> Retry on fail attempts count </param>
            <param name="cancellation"> Work cancellation token </param>
            <returns> Wrapper and work completion task </returns>
        </member>
        <member name="M:AInq.Background.Wrappers.WorkWrapperFactory.CreateWorkWrapper``1(AInq.Background.Tasks.IAsyncWork{``0},System.Int32,System.Threading.CancellationToken)">
            <summary> Create <see cref="T:AInq.Background.Wrappers.ITaskWrapper`1" /> for given asynchronous work </summary>
            <param name="work"> Work instance </param>
            <param name="attemptsCount"> Retry on fail attempts count </param>
            <param name="cancellation"> Work cancellation token </param>
            <typeparam name="TResult"> Work result type </typeparam>
            <returns> Wrapper and work result task </returns>
        </member>
    </members>
</doc>
